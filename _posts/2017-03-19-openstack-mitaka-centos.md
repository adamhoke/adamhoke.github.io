---
layout: post
title: Setting Up Openstack Mitaka on CentOS
date: 2016-03-19 22:00:00
categories: cloud
image: "/images/posts/8/bg.png"
category: blog
published: true
comments: true
tags:
- Openstack
- CentOS
- cloud
---

*Openstack setup on Centos, using rdo project repositories. Not a simple task.*


<br />
**Openstack**

Mikata is the 13th release of the Openstack cloud computing framework. 
It's the most widely deployed version of Openstack and the most stable version available. 
It has enhanced managebility from previous versions and can be deployed onto your own servers for creating a cloud.
More info can be found [here](https://www.openstack.org/software/mitaka/ "Openstack Mikata")


<br />
**RDO Project**

The RDO project is a group of developers who maintain Openstack on CentOS, Fedora, and RHEL.Amongst other things they maintain the repo that'll be used in this post.
The project's homepage can be found [here](https://www.rdoproject.org/ "RDO Project")


<br />
**Seting up Openstack on CentOS**

The first step is to install the RDO repository:

```
$ sudo yum install -y centos-release-openstack-mitaka
```
Then once that is installed, install openstack:

```
$ sudo yum install -y openstack-packstack
```

The openstack-packstack module conatains packstack in addition to openstack. 
Packstack is a utility that uses puppet and puppet modules to deploy Openstack.

Trying to run a basic openstack setup using the 'allinone' option:

```
packstack --allinone
```

Didn't work correctly on the first run. It seems the yum cache gets frequently corrupted and there are some prerequisites that need to be installed
before packstack can download and install the packages it needs. Here's a few I installed before coninuing:

```
sudo yum install -y puppet hiera openssh-clients tar nc rubygem-json erlang
```

This helped but didn't get things working. Here's the error message I recieved:

```
ERROR : Error appeared during Puppet run: 10.0.2.15_prescript.pp
Error: Execution of '/usr/bin/yum -d 0 -e 0 -y install openstack-selinux' returned 1: Error downloading packages:
You will find full trace in log /var/tmp/packstack/20170311-235531-d93RwD/manifests/10.0.2.15_prescript.pp.log
```

So I installed openstack-selinux. I also had to repeat this process with similar errors for mariadb-server-galera, python-openstackclient, and openstack-cinder.
This let me get further, but now I had a new error:

```
Could not prefetch cinder_type provider 'openstack'
```

This took some research on the internet, and I found a solution that worked for me. 
Finding the last answerfile generated by the packstack installer, I edited that answerfile to remove 'lvm' value from the 'CONFIG_CINDER_BACKEND' field, leaving it blank.
Then I moved that file to where I was running packstack from and renamed it 'answers.txt'. Now, run packstack specifying that answerfile to use:

```
no rename that file snwers.txt and run packstack --answer-file=answers.txt
```




<br />
**Obtaining an SSL Certificate**

In order to obtain a SSL certificate from a CA, the CA will ask you to generate a csr.
This can be done with a tool like openssl in one command:

```
openssl req -new -newkey rsa:2048 -nodes -keyout yourdomain.key -out yourdomain.csr
````

whats happening in this command is the user is using openenssl req command to ask for a certificate request (csr file).
The x509 flag is to specify the previously mentioned x509 standard.
The newkey flag is set since at this point there isn't a user key created.
With this flag the user is specifying the RSA 2048 encryption method (rsa:2048) and the key file name with the keyout flag.
The out flag specifies the csr file name.
You'll then submit this csr and any other appropriate information to your vendor, if you are using one.

If you wanted to self sign you own certificate, you would use a different command:

```
openssl -req x509 -in server.csr -signkey server.key -out server.crt
```

In this example you're specifying the key and csr file , and using the -out flag to specify the name of the certificate file.

If you are interested in using opwnssl to act as your own certificate authority, I will be creating a tutorial on how to do that
at a later date, and I will link it back to here.


<br />
**Installing the Certificate and running HTTPS on your server**

Now it's time to use the certificates you've created to. I'll use the simplest possible example, a Node JS server:

```    
var HTTPS = require('HTTPS');
var fs = require('fs');

var myKey = fs.readFileSync('mydomain.key');
var myCert = fs.readFileSync('mydomain.crt')

var options = {
    key: myKey,
    cert: myCert
};

HTTPS.createServer(options, function (req, res) {
    res.writeHead(200);
    res.end("HTTPS works");
}).listen(8000);
```

In nodejs it's as simple as reading the key and certificate files into the server options.

Heres an example of using that same server through apache:

```
<Proxy *>
    Order deny,allow
    Allow from all
</Proxy>
<Location />
    ProxyPass http://localhost:3000/
    ProxyPassReverse http://localhost:3000/
</Location>
```     
     
And your Apache ssl config file:

```     
LoadModule ssl_module modules/mod_ssl.so

Listen 443
<VirtualHost *:443>
    ServerName www.example.com
    SSLEngine on
    SSLCertificateFile "/path/to/www.example.com.cert"
    SSLCertificateKeyFile "/path/to/www.example.com.key"
</VirtualHost>
```   
 
<br />
**Putting It All Together**

Now lets take a step back and look at whats happening under the hood:
First a user requests a secure page over the HTTPS protocol. When this happens the web server sends back its public key and its (SSL) certificate. The browser checks to see if the certificate is issued by a trusted CA (either a vendor or internal CA).
The web browser then uses the public key to create and encrypt a random symmetric encryption key and sends it to the web server with encrypted http(s) data.
The web server decrypts the symmetric encryption key using its own private key and uses the newly decrypted symmetric key to decrypt the encrypted data, which also includes the encrypted URL
The web server sends back the requested data, in the form of an HTML document, and http data encrypted with the newly decrypted symmetric key.
The web browser decrypts the http(s) data and HTML document using the original symmetric key and displays the information.
  
<br />
**Wrapping up**

This post does not description the concepts of encryption/decryption nor what it means to be randomly symmetric. It should be clear to you why you need an SSL certificate if you need to secure data on your web server. If you can grasp the concepts here you can understand how to setup HTTPS for your web server with your own research for your choice of server and application.
